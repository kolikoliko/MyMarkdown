### 二叉树

```c++
#include <iostream>
#include <string>
#include <queue>
using namespace std;

struct BTreeNode {
    int data = 0;
    BTreeNode* left;
    BTreeNode* right;
};

class BTree {
public:
    BTree() {
    }
    //传参需要注意，二叉树是指针类型的，节点本身就是一个指针：*node。所以需要二级指针才能改变二叉树的内容
    void create(BTreeNode*& Node) {
        int data;
        cin >> data;
        if (data) {
            Node = new BTreeNode;
            Node->data = data;

            create(Node->left);
            create(Node->right);
        }
        else {
            Node = NULL;
        }
    }
    
    
    void levelCreate(BTreeNode*& Node,int N) {
        queue <BTreeNode*> que;
        string str;
        int data;
        cin >> str;
        //传进来字符串若检测到null则给赋值0，否则启用强制转换成整型
        if (str == "null") data = 0;
        else data = stoi(str);

        if (data) {
            Node = new BTreeNode;
            Node->data = data;
            que.push(Node);//进队列
            N--;
        }
        else {
            Node = NULL;
            return;
        }

        while (!que.empty()) {
            BTreeNode* node = que.front();//指针指向队列的第一位
            que.pop();//第一位出队列
            
            if (N)//检查有没有结束个数
            {
                //输入左边数据
                cin >> str;
                if (str == "null") data = 0;
                else data = stoi(str);

                if (data != 0) {
                    node->left = new BTreeNode;
                    node->left->data = data;
                    que.push(node->left);//从后面进队列
                    N--;
                }
                else {
                    node->left = NULL;
                    N--;
                }

                if (N)//嵌套检查有没有结束个数
                {
                    //输入右边数据
                    cin >> str;
                    if (str == "null") data = 0;
                    else data = stoi(str);

                    if (data != 0) {
                        node->right = new BTreeNode;
                        node->right->data = data;
                        que.push(node->right);//从后面进队列
                        N--;
                    }
                    else {
                        node->right = NULL;
                        N--;
                    }
                }
                else {
                    //这里不需要左边指向空防止删掉上面左子树添加的数据
                    node->right = NULL;
                }
            }
            else {
                node->left = NULL;
                node->right = NULL;
            }
        }
    }
 
    void clear(BTreeNode*& Node) {
        BTreeNode* p = Node;
        if (p != NULL) {
            clear(Node->left);
            clear(Node->right);
            delete p;
        }
    }
    //前序遍历(根左右)
    void preorderTree(BTreeNode* Node) {
        if (Node != NULL) {
            cout << Node->data << " ";
            preorderTree(Node->left);
            preorderTree(Node->right);
        }
        
    }
    
};

int main() {
    
    int N = 0;
    cin >> N;
    for (int i = 0; i < N; i++)
    {
        BTree tree;
        int j = 0;
        cin >> j;

        BTreeNode* root;
        tree.levelCreate(root, j);
        tree.preorderTree(root);
        tree.clear(root);
        cout << endl;
    }
    
    return 0;
}

```



### 双链表

```c
#include<iostream>
using namespace std;

typedef struct DoubleLinkList {

    int data;  //结点的数据域

    DoubleLinkList* next; //下一个结点的指针域

    DoubleLinkList* prev; //上一个结点的指针域

}DoubleLinkList, DoubleLinkNode;


bool DoubleLinkListInit(DoubleLinkList*& L) { //构造一个空的双向链表

    L = new DoubleLinkNode; //生成新结点作为头结点，用头指针L指向新结点
    if (!L)return true;  //生成结点失败

    L->next = NULL;  //头结点的next指针域指空
    L->prev = NULL;  //头结点的prev指针域指空
    L->data = -1;
    return true;
}

void DoubleLinkListInsert(DoubleLinkList* L, int x, int data) {
    int j = 0;
    int Final_Flag = 0;
    DoubleLinkList* p, * s;
    p = L;

    for (int i = 0; i < x; i++)
    {
        if (p->next)
        {
            p = p->next;
        }
        else
        {
            Final_Flag = 1;
            break;
        }
    }

    if (!Final_Flag)
    {
        s = new DoubleLinkNode;
        s->data = data;

        s->next = p;
        s->prev = p->prev;

        p->prev->next = s;
        p->prev = s;
    }
    else
    {
        s = new DoubleLinkNode;
        s->data = data;

        s->next = NULL;
        s->prev = p;
        p->next = s;
    }


}

//双向链表的遍历输出
void DoubleLinkListPrint(DoubleLinkList*& L, int Mode) {

    DoubleLinkNode* p = L;

    if (!L) {
        cout << "NULL" << endl;
        return;
    }
    if (!L->next) {
        cout << "NULL" << endl;
        return;
    }

    if (Mode == 1)
    {
        while (p->next) {
            cout << p->next->data << " ";
            p = p->next;
        }
        cout << endl;
    }
    else if (Mode == 2)
    {
        //逆向打印
        while (p->next) {
            p = p->next;
        }
        while (p->prev) {
            cout << p->data << " ";
            p = p->prev;
        }
        cout << endl;
    }




}

void DoubleLinkListDelete(DoubleLinkList*& L, int Num)
{
    DoubleLinkNode* p = L;

    p = L;
    while (p->next) {
        if (p->data == Num)
        {
            DoubleLinkNode* s = new DoubleLinkNode;
            s = p;
            p = p->next;
            s->prev->next = s->next;
            s->next->prev = s->prev;
            delete s;
        }
        p = p->next;
    }
}

int main() {
    DoubleLinkList* L;
    DoubleLinkListInit(L);

    string str;
    while (1) {
        cin >> str;
        if (str == "insert") {
            int n, x, data;
            int count = 0;

            cin >> n;
            int* y = new int[n];
            cin >> x;
            x++;//从后面那个数字开始插入
            for (int i = 0; i < n; i++) {
                cin >> y[i];
            }
            for (int i = 0; i < n; i++) {
                data = y[i];
                //cout << "data" << data << endl;
                DoubleLinkListInsert(L, x, data);
                x += 1;
            }
        }

        else if (str == "show") {
            DoubleLinkListPrint(L, 1);
        }

        else if (str == "rshow") {
            DoubleLinkListPrint(L, 2);
        }
        else if (str == "delete") {
            int mydelete;
            cin >> mydelete;
            DoubleLinkListDelete(L, mydelete);
        }

        else if (str == "END") {
            break;
        }
    }

}
```

### 

### 罗马数字

```c++
#include<iostream>
#include<string>
using namespace std;

void RomanToint(string roman) {
    int values[] = { 1000,500,100,50,10,5,1 };
    char reps[] = { 'M','D','C','L','X','V','I' };
    int result = 0;
    int res[100] = {};

    int CountD = 0;
    int CountL = 0;
    int CountV = 0;

    for (int i = 0; i < roman.size(); i++) {//遍历roman字符串
        res[i] = 0;//
        for (int j = 0; j < 7; j++) {///用字符串匹配reps里面的字母
            if (roman[i] == reps[j]) {//匹配成

                result += values[j];//result加上reps 对应的value （j相同）
                res[i] = values[j]; //把value计入res
            }
        }
        switch (roman[i])
        {
        case 'D':CountD++;
            break;
        case 'L':CountL++;
            break;
        case 'V':CountV++;
            break;
        default:
            break;
        }
    }
    int new_flag = 1;
    if (CountD > 1 || CountL > 1 || CountV > 1)
    {
        cout << "WRONG" << endl;
        new_flag = 0;
    }
    else
    {
        for (int i = 0; i < roman.size(); i++) {

            if (res[i] < res[i + 1]) {
                if (5 * res[i] == res[i + 1] || 10 * res[i] == res[i + 1]) {
                    for (int j = 0; j < 7; j++) {
                        if (roman[i] == reps[j]) {
                            result -= 2 * values[j];
                        }
                    }
                }
                else {
                    cout << "WRONG" << endl;
                    new_flag = 0;
                    break;
                }

            }
        }
    }

    if (new_flag) {
        cout << result << endl;
    }

}

int main() {
    int N;
    cin >> N;
    string* Str = new string[N];
    getline(cin, Str[0]);

    for (int i = 0; i < N; i++) {
        string roman;
        int flag = 0;
        cin >> roman;
        for (int j = 0; j < roman.size(); j++) {
            if (roman[j] != 'M' && roman[j] != 'D' && roman[j] != 'C' && roman[j] != 'L' && roman[j] != 'X' && roman[j] != 'V' && roman[j] != 'I') {
                cout << "WRONG" << endl;
                flag = 1;
                break;
            }
        }

        if (roman.size() >= 4) {
            for (int i = 0; i < roman.size() - 3; i++) {
                if ((roman[i] == roman[i + 1]) && (roman[i] == roman[i + 2]) && (roman[i] == roman[i + 3])) {
                    cout << "WRONG" << endl;
                    flag = 1;
                }

            }
        }
        if (flag == 0) {
            RomanToint(roman);
        }

    }

}
```



