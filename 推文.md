# 无协新媒体推文

## xxxxxxxxxx #include <iostream>#include <string>#include <queue>using namespace std;​struct BTreeNode {    int data = 0;    BTreeNode* left;    BTreeNode* right;};​class BTree {public:    BTree() {    }    //传参需要注意，二叉树是指针类型的，节点本身就是一个指针：*node。所以需要二级指针才能改变二叉树的内容    void create(BTreeNode*& Node) {        int data;        cin >> data;        if (data) {            Node = new BTreeNode;            Node->data = data;​            create(Node->left);            create(Node->right);        }        else {            Node = NULL;        }    }            void levelCreate(BTreeNode*& Node,int N) {        queue <BTreeNode*> que;        string str;        int data;        cin >> str;        //传进来字符串若检测到null则给赋值0，否则启用强制转换成整型        if (str == "null") data = 0;        else data = stoi(str);​        if (data) {            Node = new BTreeNode;            Node->data = data;            que.push(Node);//进队列            N--;        }        else {            Node = NULL;            return;        }​        while (!que.empty()) {            BTreeNode* node = que.front();//指针指向队列的第一位            que.pop();//第一位出队列                        if (N)//检查有没有结束个数            {                //输入左边数据                cin >> str;                if (str == "null") data = 0;                else data = stoi(str);​                if (data != 0) {                    node->left = new BTreeNode;                    node->left->data = data;                    que.push(node->left);//从后面进队列                    N--;                }                else {                    node->left = NULL;                    N--;                }​                if (N)//嵌套检查有没有结束个数                {                    //输入右边数据                    cin >> str;                    if (str == "null") data = 0;                    else data = stoi(str);​                    if (data != 0) {                        node->right = new BTreeNode;                        node->right->data = data;                        que.push(node->right);//从后面进队列                        N--;                    }                    else {                        node->right = NULL;                        N--;                    }                }                else {                    //这里不需要左边指向空防止删掉上面左子树添加的数据                    node->right = NULL;                }            }            else {                node->left = NULL;                node->right = NULL;            }        }    }     void clear(BTreeNode*& Node) {        BTreeNode* p = Node;        if (p != NULL) {            clear(Node->left);            clear(Node->right);            delete p;        }    }    //前序遍历(根左右)    void preorderTree(BTreeNode* Node) {        if (Node != NULL) {            cout << Node->data << " ";            preorderTree(Node->left);            preorderTree(Node->right);        }            }    };​int main() {        int N = 0;    cin >> N;    for (int i = 0; i < N; i++)    {        BTree tree;        int j = 0;        cin >> j;​        BTreeNode* root;        tree.levelCreate(root, j);        tree.preorderTree(root);        tree.clear(root);        cout << endl;    }        return 0;}​c++

推文的主题色选择（最右边的一个），这个一般是无协的主题色，但是可以根据推文的内容进行修改

![image-20221102120717788](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102120717788.png)

推文的开头和结尾加上图片，无协的推文开头结尾，可以在无协的网盘里面找到压缩包文件

![image-20221102120808515](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102120808515.png)

![image-20221102120852522](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102120852522.png)

最后的最后附上结尾，根据不同的底色修改字体的颜色，一般选取淡黑色，居中，14号字体可以根据不同的分工修改前面的内容。

![image-20221102121129734](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102121129734.png)



## 内容



## 美化

![image-20221102121255193](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102121255193.png)

减少使用白色无底的样式，最好采用底色卡片进行美化，比如下面那个，上面那个是反例（可以将所有内容放在一个底色卡片里面）



![image-20221102123751924](C:\Users\16650\AppData\Roaming\Typora\typora-user-images\image-20221102123751924.png)

可以通过加粗，换颜色来突出推文的重点内容



